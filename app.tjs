var express = require('express'),
    connect = require('connect');
var fs = require('fs');
var ejs = require('ejs');

var files = require("./files");
var errorSave = require('./filesave').named("lint-errors");
var userActionLog = require('./filesave').named("user-actions");
var db = require('./db');
var helpers = require('./helpers');
var codeutils = require('./codeutils');

var port = process.env.PORT || 8000;

var app = express.createServer();
// var io = require('socket.io').listen(app, {'log level': 1});

var logStream;
try {
  logStream = new files.DatedFileStream('logs/access-%y-%m-%d.log');
} catch (e) {
  process.exit(1);
}
app.configure(function() {
  this.set('views', __dirname + '/templates');
  this.set('view engine', 'ejs');
  this.register('.html', ejs);
  this.dynamicHelpers({
    helpers: function(req, res) { return new helpers.Helpers(req, res); }
  });
  this.use(express.logger({
    buffer: true,
    stream: logStream,
    format: ':remote-addr - - [:date] ":method :url HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent" :response-time ms'
  }));
  this.use(express.cookieParser());
  this.use(express.bodyParser());
  this.use(connect.static(__dirname + '/static'));
});

var savedCode = {
  run: {
    d: fs.readFileSync('code/run.js', 'utf8'),
    i: codeutils.instrumentSync(fs.readFileSync('code/run.js', 'utf8'), "run")
  },
  rudy: {
    d: fs.readFileSync('code/robot.js', 'utf8'),
    i: codeutils.instrumentSync(fs.readFileSync('code/robot.js', 'utf8'), "rudy")
  },
};

app.get('/', function(req, res, next) {
  res.render('home.html');
});

var argHandler = {
  rudy: function(doc, args, cb) {
    if ('cloneCode' in args) {
      await db.in('sketches').get(args.cloneCode, defer (var err, oldDoc));
      if (err) { return cb(err); }
      doc.latestCode = oldDoc.latestCode;
      doc.versions.push(oldDoc.versions[oldDoc.versions.length-1]);
      if (!doc.extra) {doc.extra = {};}
      doc.extra.clonedFrom = args.cloneCode;
    }
    ['level', 'evaluationDelay'].forEach(function(k) {
      if (k in args) {
        if (!doc.extra) {doc.extra = {};}
        doc.extra[k] = args[k];
      }
    });
    cb(null, ('cloneCode' in args) ? function(doc, cb) {
      db.in('sketches').update(args.cloneCode, {'$set': {'extra.clonedTo': doc._id}}, cb);
    } : undefined);
  }
};

app.get('/new/:template?', function(req, res, next) {
  var template = req.params.template || 'run';
  var newDoc = {latestCode: savedCode[template].d, versions: [savedCode[template]]};
  var err, followup_f;
  if (template in argHandler) {
    await argHandler[template](newDoc, req.query, defer (err, followup_f));
    if (err) {
      return res.render('500.html', {err: err});
    }
  }
  await db.in('sketches').create(newDoc, defer (var err, doc));
  if (err) {
    return res.render('500.html', {err: err});
  }
  if (followup_f) {
    await followup_f(doc, defer (var err));
    if (err) {
      return res.render('500.html', {err: err});
    }
  }
  res.redirect('/edit/'+template+'/'+doc._id);
});
app.get('/edit/:template/:id', function(req, res, next) {
  var template = req.params.template || 'run';
  await db.in('sketches').get(req.params.id, defer (var err, doc));
  if (err) {
    return res.render('500.html', {err: err});
  }
  if (! doc) {
    return res.render('404.html');
  }
  // await sharejsServer.model.getSnapshot(req.params.id, defer (var err, data));
  // if (err && err !== 'Document does not exist') {
  //   return res.render('500.html', {err: err});
  // }
  res.render('edit-'+template+'.html', {template: template, extra: doc.extra, initialCode: /*data ? data.snapshot :*/ doc.latestCode, sketchId: req.params.id, clientId: ""+Math.round(Math.random()*1000000000)});
});

var redirects = {};
app.post('/save/:sketchId', function(req, res, next) {
  var code = req.param('code');
  var saveVersion = req.param('saveVersion') == "true";
  var instrumentedCode = saveVersion ? codeutils.instrumentSync(code, req.param('template')) : "uncomputed, no version save";

  userActionLog.save({
    type: (saveVersion ? "play" : "save"),
    clientId: req.param('clientId'),
    sketchId: req.params.sketchId,
    code: code
  });

  var updateParams = { 
    $set: { latestCode: code }
  };
  if (req.param('extra')) {
    updateParams['$set'].extra = JSON.parse(req.param('extra'));
  }
  if (saveVersion) {
    updateParams['$push'] = { versions: {d: code, i: instrumentedCode }};
  }
  await db.in('sketches').update(req.params.sketchId, updateParams, defer (var err));
  
  var output = {};
  if (! saveVersion) {
    output = {status: err ? err : 'ok'};
    // console.log("saved latest: ", code);
  } else {
    await db.in('sketches').get(req.params.sketchId, defer (var err, doc));
  
    // var id = req.param('id');
    var version = doc.versions.length-1;
  
    // this is really suboptimal, but in practice, should almost never be an issue.
    while (version > -1) {
      if (doc.versions[version].d == code) {
        break;
      } else {
        version--;
      }
    }
    if (version < 0) {
      version = doc.versions.length-1;
    }
    // if (redirects[id]) {
    //   redirects[id](version);
    //   delete redirects[id];
    // } else {
    //   redirects[id] = version;
    // }
    output = {status: 'ok', savedVersion: version };
    // console.log("saved version", version);    
  }
  res.contentType('application/json');
  res.end(JSON.stringify(output));
});

app.post('/noteError', function(req, res, next) {
  var code = req.param('code');
  var errors = req.param('errors');
  errorSave.save({
    clientId: req.param('clientId'),
    sketchId: req.param('sketchId'),
    code: code,
    errors: JSON.parse(errors)
  });
  userActionLog.save({
    type: "errors",
    clientId: req.param('clientId'),
    sketchId: req.param('sketchId'),
    code: code,
    errors: JSON.parse(errors)
  });
});

var templateMap = {
  run: 'view.html',
  rudy: 'robot.html'
};

app.get('/play/:template/:sketch/:client/:id', function(req, res, next) {
  var id = req.params.id;
  var f = function(version) {
    res.cookie("nextclientid", req.params.client, {maxAge: 360000, path: '/' });
    res.redirect('/play/'+[req.params.template, req.params.sketch, version].join('/'));
    delete redirects[id];    
  };
  if (redirects[id]) {
    f(redirects[id]);
  } else {
    redirects[id] = f;
  }
});

app.get('/play/:template/:id/:version', function(req, res, next) {
  var id = req.params.id;
  var version = Number(req.params.version);
  if (isNaN(version)) {
    version = -1;
  }
  var clientId = req.cookies.nextclientid;

  await db.in('sketches').get(req.params.id, defer (var err, doc));
  if (err) {
    console.log("couldn't get document", err);
  }
  if (doc && doc.versions) {
    res.clearCookie('nextClientId');
    res.render(templateMap[req.params.template] || 'view.html', {
      layout: false, code: doc.versions[version < 0 ? doc.versions.length-1 : version].i, sketchId: req.params.sketch, clientId: clientId ? clientId : null
    });
  } else {
    res.render("500.html", {err: "Saved sketch not found!"});
  }
});

// set up runtime error handling
// var socketRegistrations = {};
// io.sockets.on('connection', function(socket) {
//   var id;
//   socket.on('register', function(data) {
//     socketRegistrations[id = data.id] = socket;
//   });
//   socket.on('disconnect', function() {
//     delete socketRegistrations[id];
//   });
// });
app.post('/runtimeError', function(req, res, next) {
  var id = req.param('id');
  if (socketRegistrations[id]) {
    socketRegistrations[id].emit('runtime error', {line: Number(req.param('line')), char: Number(req.param('char')), msg: req.param("msg")});
  }
  res.end(JSON.stringify({status: 'ok'}));
});

// set up sharejs
// var sharejs = require('share');
// var options = {
//   db: {type: 'mongo'},
//   browserChannel: {cors: '*'},
//   auth: function(client, action) {
// 		// This auth handler rejects any ops bound for docs starting with 'readonly'.
//     if (action.name === 'submit op' && action.docName.match(/^readonly/)) {
//       action.reject();
//     } else {
//       action.accept();
//     }
//   }
// };
// var sharejsServer = sharejs.server.attach(app, options);

// and now, if nothing hits...
app.use(function(req, res) {
  res.render('404.html', 404);
});

console.log("setup completed.");

// error handling
process.on('uncaughtException', function(err) {
  console.log('Caught unhandled exception.');
  console.log(err.stack);
});

// db setup
await db.init(defer (var err));
if (err) {
  console.log("Failed to connect to DB", err);
  process.exit(1);
}
app.listen(port);
console.log("Listening on port", port);
